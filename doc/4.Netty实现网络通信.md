## 1. netty协议制定——ByteBuf编解码

- ByteBuf是netty提供的字节操作类，对应JDK NIO中ByteBuffer
- 为什么需要ByteBuf?

> Netty实战中写：网络数据最基本的单位是字节
> *所有网络通信都涉及到字节序列的移动*（没有理解，为什么？），所以高效易用的数据结构明显是必不可少的。

- 为什么重新写一个ByteBuf?NIO提供的ByteBuffer过于复杂也繁琐

> 举例：ByteBuf拥有读、写两个索引相互不会干扰
>   而ByteBuffer却只有一个，需要用`flip()`方法切换读、写模式。

编写编解码：

**编码器**:

```java
@AllArgsConstructor
public class NettyKryoEncode extends MessageToByteEncoder<Object> {

    private Serializer serializer;
    private Class<?> genericClazz;

    /**
     * 编码器 将object编码为 ByteBuf
     *
     * 编码方式为：ByteBuf头为 body（byte[]长度）后续紧跟着byte[]内容
     * @param ctx
     * @param msg
     * @param out
     * @throws Exception
     */
    @Override
    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {
        if (genericClazz.isInstance(msg)) {
            byte[] body = serializer.serialize(msg);
            int length = body.length;
            //1. 头写入 长度 int 4字节
            out.writeInt(length);
            //2. 后续写入 内容
            out.writeBytes(body);
        }
    }
}
```

**解码器：**

```java
@AllArgsConstructor
public class NettyKryoDecode extends ByteToMessageDecoder {

    private Serializer serializer;
    private Class<?> genericClazz;

    private static final int BODY_LEN = 4;//int四字节

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        //1. 此方法返回可读长度，因为我们自定义的是 头-》body的数组长度值（int）本身必须占四字节，所以小于四字节一律不考虑
        if (in.readableBytes() >= BODY_LEN) {
            //2. 标记当前要读的位置，以便重试
            in.markReaderIndex();
            //3. 获取body长度
            int dataLen = in.readInt();
            //4. 校验不合理情况
            if (dataLen < 0 || in.readableBytes() < 0) {
                return;
            }
            if (in.readableBytes()<dataLen){
                //5. 当小于datalen说明数据不完整,重置读位置
                in.resetReaderIndex();
                return;
            }
            //6. 可以反序列化了
            byte[] bytes = new byte[dataLen];
            in.readBytes(bytes);
            Object obj = serializer.deserialize(bytes, genericClazz);
            out.add(obj);
        }
    }
}
```

两点要注意：

- 写入的时候：一个是我们定义的编解码方式：header(body字节的长度 int值)+body(内容字节数组)
关键是 **int值占4个字节，并且每调用一次`out.writeInt(length);`方法都会往后占用4字节。**

- 读取的时候：需要判断自定义协议的合法性，关键点处理—— header值>字节长度，说明写入未完成。所以需要最开始先标记一下`in.markReaderIndex();`读取的位置，
当reset方法`in.resetReaderIndex();`时会回到这个标记的位置上

2. handle编写
3. netty网络模型
4. netty调试经验

5. 为什么这么设计？
DefaultServiceRegistry-》serviceMap、registryService是static
